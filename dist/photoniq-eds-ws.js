/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PhotoniqEdsWs"] = factory();
	else
		root["PhotoniqEdsWs"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/filters-state.ts":
/*!******************************!*\
  !*** ./src/filters-state.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ADD: () => (/* binding */ ADD),\n/* harmony export */   FALSE: () => (/* binding */ FALSE),\n/* harmony export */   FiltersState: () => (/* binding */ FiltersState),\n/* harmony export */   REMOVE: () => (/* binding */ REMOVE),\n/* harmony export */   TRUE: () => (/* binding */ TRUE)\n/* harmony export */ });\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nconst FALSE = \"FALSE\";\nconst TRUE = \"TRUE\";\nconst ADD = \"add\";\nconst REMOVE = \"remove\";\nclass FiltersState {\n    constructor(globalListener) {\n        this.queries = new Map();\n        this.globalListener = globalListener;\n    }\n    calculateFilter(action, query, filterState) {\n        const initialData = filterState.querySets.some(qs => qs.initialData && qs.count === 0) ? TRUE : undefined;\n        const once = filterState.querySets.every(qs => qs.once) ? TRUE : undefined;\n        const compress = filterState.querySets.some(qs => qs.compress) ? TRUE : undefined;\n        return {\n            action: action,\n            queries: [query],\n            initialData: initialData,\n            once: once,\n            compress: compress\n        };\n    }\n    increment(filterState) {\n        // increment count for each query set\n        for (const qs of filterState.querySets) {\n            qs.count++;\n        }\n    }\n    tryToRemove(filterState, query) {\n        if (filterState.querySets.every(qs => qs.once)) {\n            this.queries.delete(query);\n            return {\n                action: REMOVE,\n                queries: [query]\n            };\n        }\n        return undefined;\n    }\n    equalFiltersWithoutQueries(a, b) {\n        return a.action === b.action &&\n            a.compress === b.compress &&\n            a.initialData === b.initialData &&\n            a.once === b.once;\n    }\n    addQueries(queries, initialData, once, compress, querySet) {\n        let filtersToAdd = [];\n        for (const query of queries) {\n            let filterState = this.queries.get(query.query);\n            if (filterState) {\n                let filterBefore = this.calculateFilter(ADD, query.query, filterState);\n                let querySetWithFilter = filterState.querySets.find(qs => qs.querySet === querySet);\n                if (querySetWithFilter) {\n                    querySetWithFilter.initialData = initialData;\n                    querySetWithFilter.once = once;\n                    querySetWithFilter.compress = compress;\n                    if (initialData) {\n                        querySetWithFilter.count = 0;\n                    }\n                    if (querySetWithFilter.callbacks.indexOf(query.listener) == -1) {\n                        querySetWithFilter.callbacks.push(query.listener);\n                    }\n                    if (querySetWithFilter.errorCallbacks.indexOf(query.errorListener) == -1) {\n                        querySetWithFilter.errorCallbacks.push(query.errorListener);\n                    }\n                }\n                else {\n                    let callbacks = [];\n                    if (query.listener) {\n                        callbacks.push(query.listener);\n                    }\n                    let errorCallbacks = [];\n                    if (query.errorListener) {\n                        errorCallbacks.push(query.errorListener);\n                    }\n                    filterState.querySets.push({\n                        querySet: querySet,\n                        initialData: initialData,\n                        compress: compress,\n                        once: once,\n                        count: 0,\n                        callbacks: query.listener ? [query.listener] : [],\n                        errorCallbacks: query.errorListener ? [query.errorListener] : [],\n                    });\n                }\n                let filterAfter = this.calculateFilter(ADD, query.query, filterState);\n                if (!this.equalFiltersWithoutQueries(filterBefore, filterAfter)) {\n                    let filter = filtersToAdd.find(f => this.equalFiltersWithoutQueries(f, filterAfter));\n                    if (filter) {\n                        filter.queries.push(query.query);\n                    }\n                    else {\n                        filtersToAdd.push(filterAfter);\n                    }\n                }\n            }\n            else {\n                let filterState = {\n                    querySets: [{\n                            querySet: querySet,\n                            initialData: initialData,\n                            compress: compress,\n                            once: once,\n                            count: 0,\n                            callbacks: query.listener ? [query.listener] : [],\n                            errorCallbacks: query.errorListener ? [query.errorListener] : [],\n                        }]\n                };\n                this.queries.set(query.query, filterState);\n                let filterAfter = this.calculateFilter(ADD, query.query, filterState);\n                let filter = filtersToAdd.find(f => this.equalFiltersWithoutQueries(f, filterAfter));\n                if (filter) {\n                    filter.queries.push(query.query);\n                }\n                else {\n                    filtersToAdd.push(filterAfter);\n                }\n            }\n        }\n        return filtersToAdd;\n    }\n    filterForQuery(query) {\n        return this.queries.get(query);\n    }\n    removeAllQueries(querySet) {\n        let queries = Array.from(this.queries.keys());\n        return this.removeQueries(queries, querySet);\n    }\n    removeQueries(queries, querySet) {\n        let queriesToRemove = [];\n        for (const query of queries) {\n            let remove = true;\n            let filterState = this.queries.get(query);\n            if (filterState) {\n                let index = filterState.querySets.findIndex(qs => qs.querySet === querySet);\n                if (index > -1) {\n                    filterState.querySets.splice(index, 1);\n                }\n                if (filterState.querySets.length) {\n                    remove = false;\n                }\n            }\n            if (remove) {\n                this.queries.delete(query);\n                queriesToRemove.push(query);\n            }\n        }\n        if (queriesToRemove.length) {\n            return {\n                action: REMOVE,\n                queries: queriesToRemove\n            };\n        }\n        return undefined;\n    }\n    activeFilters() {\n        let filters = [];\n        for (const [query, filterState] of this.queries) {\n            const filter = this.calculateFilter(ADD, query, filterState);\n            let filterFound = filters.find(f => this.equalFiltersWithoutQueries(f, filter));\n            if (filterFound) {\n                filterFound.queries.push(query);\n            }\n            else {\n                filters.push(filter);\n            }\n        }\n        return filters;\n    }\n    handleErrorListeners(errorCallbacks, query, edsEvent) {\n        for (let callback of errorCallbacks) {\n            try {\n                callback(edsEvent);\n            }\n            catch (e) {\n                console.warn(`Error while handling error listener for query: ${query}`, e);\n            }\n        }\n    }\n    handleGlobalListener(edsEvent) {\n        var _a;\n        try {\n            (_a = this.globalListener) === null || _a === void 0 ? void 0 : _a.call(this, edsEvent);\n        }\n        catch (e) {\n            console.warn(`Error while handling global error listener`, e);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/filters-state.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _switchable_connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./switchable-connection */ \"./src/switchable-connection.ts\");\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\n\n/**\n * Create a new connection innstance.\n * @param config configuration for the connection\n * @param globalListener listen all `EDSEvent` events.\n * @module connection\n */\nfunction create(config, globalListener) {\n    let connection = new _switchable_connection__WEBPACK_IMPORTED_MODULE_0__.SwitchableConnection(config, globalListener);\n    return connection;\n}\n/**\n * Create a new connection innstance and establish connection to PhotonIQ EDS server.\n * @param config configuration for the connection\n * @param globalListener listen all `EDSEvent` events.\n * @module connection\n */\nfunction connect(config, globalListener) {\n    let connection = new _switchable_connection__WEBPACK_IMPORTED_MODULE_0__.SwitchableConnection(config, globalListener);\n    connection.connect();\n    return connection;\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/index.ts?");

/***/ }),

/***/ "./src/query-batch.ts":
/*!****************************!*\
  !*** ./src/query-batch.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryBatch: () => (/* binding */ QueryBatch)\n/* harmony export */ });\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\n/**\n * @module QueryBatch\n * Joins all querues togather and sends as a batch\n */\nclass QueryBatch {\n    /** @ignore */\n    constructor(querySet, connection, filtersState) {\n        this.subscribeQueries = [];\n        this.retrieveAndSubscribeQueries = [];\n        this.retrieveQueries = [];\n        this.unsubscribeQueries = [];\n        this.querySet = querySet;\n        this.connection = connection;\n        this.filtersState = filtersState;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        this.subscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener,\n            compress: false\n        });\n        return this;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     * @param compress compress initial data\n     */\n    retrieveAndSubscribe(query, listener, errorListener, compress) {\n        this.retrieveAndSubscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener,\n            compress: compress === true\n        });\n        return this;\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     * @param compress compress initial data\n     */\n    retrieve(query, listener, errorListener, compress) {\n        this.retrieveQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener,\n            compress: compress === true\n        });\n        return this;\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        this.unsubscribeQueries.push(query);\n        return this;\n    }\n    /**\n     * Assemble list of queries to batch request\n     */\n    assemble() {\n        let filters = this.filtersState.addQueries(this.retrieveQueries, true, true, false, this.querySet);\n        let retrieveAndSubscribeFilters = this.filtersState.addQueries(this.retrieveAndSubscribeQueries, true, false, false, this.querySet);\n        this.joinFilters(filters, retrieveAndSubscribeFilters);\n        let subscribeFilters = this.filtersState.addQueries(this.subscribeQueries, false, false, false, this.querySet);\n        this.joinFilters(filters, subscribeFilters);\n        for (const filterToAdd of filters) {\n            this.connection.send(filterToAdd);\n        }\n        let unsubscribeFilter = this.filtersState.removeQueries(this.unsubscribeQueries, this.querySet);\n        if (unsubscribeFilter) {\n            this.connection.send(unsubscribeFilter);\n        }\n    }\n    joinFilters(target, source) {\n        for (const sourceFilter of source) {\n            let filter = target.find(f => this.filtersState.equalFiltersWithoutQueries(f, sourceFilter));\n            if (filter) {\n                filter.queries.push(...sourceFilter.queries);\n            }\n            else {\n                target.push(sourceFilter);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-batch.ts?");

/***/ }),

/***/ "./src/query-set.ts":
/*!**************************!*\
  !*** ./src/query-set.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuerySet: () => (/* binding */ QuerySet)\n/* harmony export */ });\n/* harmony import */ var _query_batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./query-batch */ \"./src/query-batch.ts\");\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\n\n/**\n * Manages queries as a set\n */\nclass QuerySet {\n    /** @ignore */\n    constructor(connection, filtersState) {\n        this.connection = connection;\n        this.filtersState = filtersState;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener,\n                compress: false\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, false, false, false, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(filterToAdd);\n        }\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     * @param compress compress initial data\n     */\n    retrieveAndSubscribe(query, listener, errorListener, compress) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener,\n                compress: compress === true\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, true, false, compress === true, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(filterToAdd);\n        }\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     * @param compress compress initial data\n     */\n    retrieve(query, listener, errorListener, compress) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener,\n                compress: compress === true\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, true, true, compress === true, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(filterToAdd);\n        }\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        let filterToRemove = this.filtersState.removeQueries([query], this);\n        if (filterToRemove) {\n            this.connection.send(filterToRemove);\n        }\n    }\n    /**\n     * Unsubscribe from all query in the QuerySet.\n     */\n    unsubscribeAll() {\n        let filter = this.filtersState.removeAllQueries(this);\n        if (filter) {\n            this.connection.send(filter);\n        }\n    }\n    /**\n     * Create QueryBatch instance to join all queries in one request and assemble at the end.\n     */\n    batch() {\n        return new _query_batch__WEBPACK_IMPORTED_MODULE_0__.QueryBatch(this, this.connection, this.filtersState);\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-set.ts?");

/***/ }),

/***/ "./src/sse/event-source.ts":
/*!*********************************!*\
  !*** ./src/sse/event-source.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventSource: () => (/* binding */ EventSource)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass EventSource {\n    constructor(url, headers) {\n        this.properties = {};\n        this.url = url;\n        this.headers = headers;\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n    }\n    connect(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            try {\n                const response = yield fetch(this.url, {\n                    method: 'POST',\n                    headers: this.headers,\n                    body: JSON.stringify(data),\n                });\n                if (!response.ok) {\n                    (_a = this.errorListener) === null || _a === void 0 ? void 0 : _a.call(this, response);\n                }\n                else {\n                    (_b = this.openListener) === null || _b === void 0 ? void 0 : _b.call(this, response);\n                }\n                const stream = response.body;\n                let buffer = \"\";\n                this.reader = stream.getReader();\n                let streamResult;\n                while (!(streamResult = yield this.reader.read()).done) {\n                    let result = new TextDecoder('utf-8').decode(streamResult.value);\n                    buffer += result;\n                    let endIndex = buffer.indexOf(\"\\n\\n\");\n                    if (endIndex > -1) {\n                        //message complete\n                        let message = buffer.substring(0, endIndex);\n                        buffer = buffer.substring(endIndex + 2);\n                        if (message.startsWith(\":\")) {\n                            const lines = result.split(\"\\n\");\n                            for (const line of lines) {\n                                const keyValue = line.split(\":\");\n                                if (keyValue.length == 3) {\n                                    this.properties[keyValue[1].trim()] = keyValue[2].trim();\n                                }\n                            }\n                        }\n                        else {\n                            let valueIndex = message.indexOf(\":\");\n                            if (valueIndex > -1) {\n                                let key = message.substring(0, valueIndex).trim();\n                                if (message[valueIndex + 1] === \" \")\n                                    valueIndex++;\n                                valueIndex++;\n                                let value = message.substring(valueIndex).replace(/\\ndata: ?/g, \"\\n\");\n                                switch (key) {\n                                    case \"data\":\n                                        (_c = this.messageListener) === null || _c === void 0 ? void 0 : _c.call(this, value);\n                                        break;\n                                    default:\n                                        console.warn(`Not supported message with type of message ${key}: ${value}`);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                (_d = this.errorListener) === null || _d === void 0 ? void 0 : _d.call(this, error);\n            }\n        });\n    }\n    disconnect() {\n        var _a;\n        (_a = this.reader) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    getProperty(name) {\n        return this.properties[name];\n    }\n    getProperties() {\n        return this.properties;\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/sse/event-source.ts?");

/***/ }),

/***/ "./src/sse/sse-connection.ts":
/*!***********************************!*\
  !*** ./src/sse/sse-connection.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SseConnection: () => (/* binding */ SseConnection)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _event_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-source */ \"./src/sse/event-source.ts\");\n/* harmony import */ var _filters_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../filters-state */ \"./src/filters-state.ts\");\n\n\n\nclass SseConnection {\n    constructor(config, filtersState) {\n        this.config = config;\n        this.filtersState = filtersState;\n        this.url = `https://${this.config.host}/api/es/sse/v1/subscribe`;\n        this.headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `${this.config.apiKey}`,\n            'x-customer-id': `${this.config.customerId}`,\n        };\n    }\n    send(filter) {\n    }\n    /**\n     * Connect to SSE server\n     */\n    connect() {\n        let filters = this.filtersState.activeFilters();\n        this.retrieve(filters);\n        /*const url: string = `https://${this.config.host}/api/es/sse/v1/subscribe`;\n        let data = {\n            \"type\": \"collection\",\n            \"fabric\": \"_system\",\n            \"filters\": {\n                \"once\": \"FALSE\",\n                \"compress\": \"FALSE\",\n                \"initialData\":\"TRUE\",\n                \"queries\": [\"select * from box_trim where attendance=4\"]\n            }\n        };\n        \n        this.sseSubscribe = new EventSource(url, {\n            'Content-Type': 'application/json',\n            'Authorization': `${this.config.apiKey}`,\n            'x-customer-id': `${this.config.customerId}`,\n        });*/\n        //let self = this;\n        //this.sseSubscribe.onOpen = (event: any) => {\n        //    console.log('Connection to SSE server opened.', event);\n        /*const edsEvent: EDSEvent = {\n            type: EDSEventType.Open,\n            connection: self,\n            data: event\n        };\n        self.handleGlobalListener(edsEvent);*/\n        //};\n        //this.sseSubscribe.onMessage((event: any) => {\n        //    console.log('Received event:', event);\n        /*const edsEvent: EDSEvent = {\n            type: EDSEventType.Message,\n            connection: self,\n            data: event\n        };\n        self.handleGlobalListener(edsEvent);*/\n        //});\n        //this.sseSubscribe.onError = (event: any) => {\n        //    console.error('Error occurred:', event);\n        /*const edsEvent: EDSEvent = {\n            type: EDSEventType.ClientGlobalError,\n            connection: self,\n            data: event\n        };\n        self.handleGlobalListener(edsEvent);*/\n        //};\n        //this.sseSubscribe.connect(data);\n    }\n    retrieve(filters) {\n        let queries = filters\n            .filter(f => f.initialData === _filters_state__WEBPACK_IMPORTED_MODULE_2__.TRUE)\n            .map(f => f.queries)\n            .reduce((acc, tags) => acc.concat(tags), []);\n        if (!queries.length) {\n            return;\n        }\n        let data = {\n            type: \"collection\",\n            fabric: this.config.fabric,\n            filters: {\n                once: _filters_state__WEBPACK_IMPORTED_MODULE_2__.TRUE,\n                compress: _filters_state__WEBPACK_IMPORTED_MODULE_2__.FALSE,\n                initialData: _filters_state__WEBPACK_IMPORTED_MODULE_2__.TRUE,\n                queries: queries\n            }\n        };\n        let self = this;\n        this.eventSource = new _event_source__WEBPACK_IMPORTED_MODULE_1__.EventSource(this.url, this.headers);\n        this.eventSource.onError((event) => {\n            const edsEvent = {\n                type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event\n            };\n            this.filtersState.handleGlobalListener(edsEvent);\n        });\n        this.eventSource.onMessage((message) => {\n            var _a;\n            if (self.handleMessage(message)) {\n                (_a = self.eventSource) === null || _a === void 0 ? void 0 : _a.disconnect();\n                self.subscribe(filters);\n            }\n        });\n        this.eventSource.connect(data);\n    }\n    subscribe(filters) {\n        let queries = filters\n            .filter(f => f.once !== _filters_state__WEBPACK_IMPORTED_MODULE_2__.TRUE)\n            .map(f => f.queries)\n            .reduce((acc, tags) => acc.concat(tags), []);\n        if (!queries.length) {\n            return;\n        }\n        let data = {\n            type: \"collection\",\n            fabric: this.config.fabric,\n            filters: {\n                once: _filters_state__WEBPACK_IMPORTED_MODULE_2__.FALSE,\n                compress: _filters_state__WEBPACK_IMPORTED_MODULE_2__.FALSE,\n                initialData: _filters_state__WEBPACK_IMPORTED_MODULE_2__.FALSE,\n                queries: queries\n            }\n        };\n        let self = this;\n        this.eventSource = new _event_source__WEBPACK_IMPORTED_MODULE_1__.EventSource(this.url, this.headers);\n        this.eventSource.onError((event) => {\n            const edsEvent = {\n                type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event\n            };\n            this.filtersState.handleGlobalListener(edsEvent);\n        });\n        this.eventSource.onMessage((message) => {\n            self.handleMessage(message);\n        });\n        this.eventSource.connect(data);\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    status() {\n        return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Closed;\n    }\n    disconnect() {\n        var _a;\n        (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.eventSource = undefined;\n    }\n    getId() {\n        return this.getProperty(_types__WEBPACK_IMPORTED_MODULE_0__.PHOTONIQ_ES);\n    }\n    getProperty(name) {\n        var _a;\n        return (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.getProperty(name);\n    }\n    getProperties() {\n        return this.eventSource ? this.eventSource.getProperties() : {};\n    }\n    handleMessage(message) {\n        let data = JSON.parse(message);\n        if (!data.error) {\n            for (let query in data) {\n                let queryData = data[query];\n                let filterState = this.filtersState.filterForQuery(query);\n                if (filterState) {\n                    this.filtersState.increment(filterState);\n                    let isInitialData = Array.isArray(queryData);\n                    if (isInitialData) {\n                        for (let i = 0; i < queryData.length; i++) {\n                            queryData[i] = this.convertInitialData(queryData[i]);\n                        }\n                    }\n                    else {\n                        queryData = [queryData];\n                    }\n                    for (const querySetWithFilter of filterState.querySets) {\n                        if (isInitialData && !querySetWithFilter.initialData)\n                            continue;\n                        let edsEvent = {\n                            type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.Message,\n                            connection: this,\n                            data: queryData,\n                            query: query,\n                            count: querySetWithFilter.count,\n                            retrieve: isInitialData,\n                        };\n                        for (let callback of querySetWithFilter.callbacks) {\n                            try {\n                                callback(edsEvent);\n                            }\n                            catch (e) {\n                                let msg = `Error while handling data for query: ${query}`;\n                                const edsEvent = {\n                                    type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ClientQueryError,\n                                    connection: this,\n                                    data: e,\n                                    message: msg,\n                                    query: query\n                                };\n                                this.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                                //self.filtersState.handleGlobalListener(edsEvent);\n                            }\n                        }\n                    }\n                    let filterToRemove = this.filtersState.tryToRemove(filterState, query);\n                }\n            }\n            return true;\n        }\n        else {\n            let msg = data.error;\n            const queryErrorPrefix = \"Error parsing SQL query:\";\n            if (msg.startsWith(queryErrorPrefix)) {\n                let query = msg.substring(queryErrorPrefix.length, msg.indexOf(\"ERROR\")).trim();\n                const edsEvent = {\n                    type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ServerQueryError,\n                    connection: this,\n                    data: undefined,\n                    code: data.code,\n                    message: msg,\n                    query: query\n                };\n                let filterState = this.filtersState.filterForQuery(query);\n                if (filterState) {\n                    for (const querySetWithFilter of filterState.querySets) {\n                        this.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                    }\n                }\n                //self.filtersState.handleGlobalListener(edsEvent);\n            }\n            else {\n                const edsEvent = {\n                    type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ServerGlobalError,\n                    connection: this,\n                    data: undefined,\n                    code: data.code,\n                    message: msg\n                };\n                this.filtersState.handleGlobalListener(edsEvent);\n            }\n        }\n        return false;\n    }\n    convertInitialData(sqlData) {\n        for (let sqlParameter in sqlData) {\n            let path = sqlParameter.split('.');\n            if (path.length <= 1) {\n                continue;\n            }\n            let value = sqlData;\n            for (let i = 0; i < path.length; i++) {\n                if (value[path[i]] === undefined) {\n                    value[path[i]] = {};\n                }\n                // if not last\n                if (i < path.length - 1) {\n                    value = value[path[i]];\n                }\n            }\n            value[path[path.length - 1]] = sqlData[sqlParameter];\n            delete sqlData[sqlParameter];\n        }\n        return sqlData;\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/sse/sse-connection.ts?");

/***/ }),

/***/ "./src/switchable-connection.ts":
/*!**************************************!*\
  !*** ./src/switchable-connection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SwitchableConnection: () => (/* binding */ SwitchableConnection)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _ws_ws_connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ws/ws-connection */ \"./src/ws/ws-connection.ts\");\n/* harmony import */ var _sse_sse_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sse/sse-connection */ \"./src/sse/sse-connection.ts\");\n/* harmony import */ var _filters_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters-state */ \"./src/filters-state.ts\");\n/* harmony import */ var _query_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query-set */ \"./src/query-set.ts\");\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\n\n\n\n\n\nclass SwitchableConnection {\n    constructor(config, globalListener) {\n        this.connectionTypes = [\"ws\"];\n        this.reconnection = -1;\n        this.config = config;\n        this.filtersState = new _filters_state__WEBPACK_IMPORTED_MODULE_3__.FiltersState(globalListener);\n    }\n    /**\n     * Connect to Web Socket server\n     */\n    connect() {\n        var _a;\n        if (this.connection)\n            throw new Error(`Already connected with status: ${this.status()}`);\n        if ((_a = this.config.connectionTypes) === null || _a === void 0 ? void 0 : _a.length) {\n            this.connectionTypes = this.config.connectionTypes;\n        }\n        let connectionType = this.connectionTypes[this.reconnection % this.connectionTypes.length];\n        switch (connectionType) {\n            case \"ws\":\n                this.connection = new _ws_ws_connection__WEBPACK_IMPORTED_MODULE_1__.WsConnection(this.config, this.filtersState);\n                break;\n            case \"sse\":\n                this.connection = new _sse_sse_connection__WEBPACK_IMPORTED_MODULE_2__.SseConnection(this.config, this.filtersState);\n                break;\n            default:\n                throw new Error(`Connection type not supported: ${connectionType}`);\n        }\n        let self = this;\n        this.connection.onOpen(function (event) {\n            var _a;\n            let reconnection = self.reconnection;\n            self.reconnection = 0;\n            if (reconnection === -1) {\n                const edsEvent = {\n                    type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.Open,\n                    connection: self,\n                    data: event\n                };\n                self.filtersState.handleGlobalListener(event);\n            }\n            // send current subscribed filters.\n            let filters = self.filtersState.activeFilters();\n            for (const filter of filters) {\n                (_a = self.connection) === null || _a === void 0 ? void 0 : _a.send(filter);\n            }\n        });\n        this.connection.onMessage(function (event) {\n            // handles on higher level, maybe TODO\n        });\n        this.connection.onError(function (event) {\n            // TODO ???\n            /*const edsEvent: EDSEvent & EDSEventError = {\n                type: EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event,\n                message: \"Client error\",\n            };\n            self.filtersState.handleGlobalListener(edsEvent);*/\n        });\n        this.connection.onClose(function (event) {\n            self.connection = undefined;\n            if (self.reconnection > -1) {\n                let millisToReconnect = Math.pow(2, 6 + self.reconnection++);\n                setTimeout(function () {\n                    self.connect();\n                }, millisToReconnect);\n            }\n            else {\n                self.reconnection = 0;\n                const edsEvent = {\n                    type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.Close,\n                    connection: self,\n                    data: event\n                };\n                self.filtersState.handleGlobalListener(edsEvent);\n            }\n        });\n        this.connection.connect();\n    }\n    /**\n     * Send data directly to web socket\n     */\n    send(filter) {\n        var _a;\n        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.send(filter);\n    }\n    /**\n     * Disconnect from web socket\n     */\n    disconnect() {\n        var _a;\n        this.reconnection = -1;\n        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    /**\n     * Get configuration of the connection\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Check weather it connected\n     */\n    status() {\n        if (this.connection) {\n            return this.connection.status();\n        }\n        else {\n            return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Closed;\n        }\n    }\n    /**\n     * Get connection id\n     */\n    getId() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.getId();\n    }\n    /**\n     * Get property\n     */\n    getProperty(name) {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.getProperty(name);\n    }\n    /**\n     * Get all properties\n     */\n    getProperties() {\n        return this.connection ? this.connection.getProperties() : {};\n    }\n    /**\n     * Create Query Set\n     */\n    querySet() {\n        return new _query_set__WEBPACK_IMPORTED_MODULE_4__.QuerySet(this, this.filtersState);\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/switchable-connection.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionStatus: () => (/* binding */ ConnectionStatus),\n/* harmony export */   EDSEventType: () => (/* binding */ EDSEventType),\n/* harmony export */   PHOTONIQ_ES: () => (/* binding */ PHOTONIQ_ES)\n/* harmony export */ });\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\n/**\n * @module Types\n *\n *\n */\nconst PHOTONIQ_ES = \"x-photoniq-es\";\n/**\n * List of event types generated by EDS driver\n*/\nvar EDSEventType;\n(function (EDSEventType) {\n    EDSEventType[\"Open\"] = \"open\";\n    EDSEventType[\"Close\"] = \"close\";\n    EDSEventType[\"ConnectionId\"] = \"connection-id\";\n    EDSEventType[\"ServerQueryError\"] = \"server-query-error\";\n    EDSEventType[\"ServerGlobalError\"] = \"server-global-error\";\n    EDSEventType[\"ClientQueryError\"] = \"client-query-error\";\n    EDSEventType[\"ClientGlobalError\"] = \"client-global-error\";\n    EDSEventType[\"Message\"] = \"message\";\n})(EDSEventType || (EDSEventType = {}));\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n    ConnectionStatus[\"Closed\"] = \"closed\";\n    ConnectionStatus[\"Connecting\"] = \"connecting\";\n    ConnectionStatus[\"Open\"] = \"open\";\n    ConnectionStatus[\"Closing\"] = \"closing\";\n})(ConnectionStatus || (ConnectionStatus = {}));\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/types.ts?");

/***/ }),

/***/ "./src/ws/ws-connection.ts":
/*!*********************************!*\
  !*** ./src/ws/ws-connection.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WsConnection: () => (/* binding */ WsConnection)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n\nclass WsConnection {\n    constructor(config, filtersState) {\n        this.STUB_FILTER = \"%7B%22action%22%3A%22remove%22%2C%22queries%22%3A%5B%22SELECT%20%2A%20FROM%20fake%22%5D%7D\";\n        /**\n         * Default timeoput of ping-pong requests in seconds\n         */\n        this.DEFAULT_PING_SECONDS = 29;\n        this.properties = {};\n        this.config = config;\n        this.filtersState = filtersState;\n    }\n    connect() {\n        let self = this;\n        const url = `wss://${this.config.host}/api/es/v1/subscribe?type=collection` +\n            `&x-customer-id=${this.config.customerId}` +\n            `&apiKey=${this.config.apiKey}` +\n            `&fabric=${this.config.fabric}` +\n            `&filters=${this.STUB_FILTER}`;\n        this.ws = new WebSocket(url);\n        this.ws.addEventListener('open', function (event) {\n            var _a;\n            (_a = self.openListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n            self.updatePingInterval();\n        });\n        this.ws.addEventListener('message', function (event) {\n            var _a;\n            let message = self.handleMessage(event);\n            if (message) {\n                (_a = self.messageListener) === null || _a === void 0 ? void 0 : _a.call(self, message);\n            }\n            self.updatePingInterval();\n        });\n        this.ws.addEventListener('close', function (event) {\n            var _a;\n            (_a = self.closeListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n        this.ws.addEventListener('error', function (event) {\n            var _a;\n            (_a = self.errorListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    handleMessage(event) {\n        let self = this;\n        if (self.properties[_types__WEBPACK_IMPORTED_MODULE_0__.PHOTONIQ_ES]) {\n            let data = JSON.parse(event.data);\n            if (!data.error) {\n                for (let query in data) {\n                    let queryData = data[query];\n                    let filterState = self.filtersState.filterForQuery(query);\n                    if (filterState) {\n                        self.filtersState.increment(filterState);\n                        let isInitialData = Array.isArray(queryData);\n                        if (isInitialData) {\n                            for (let i = 0; i < queryData.length; i++) {\n                                queryData[i] = self.convertInitialData(queryData[i]);\n                            }\n                        }\n                        else {\n                            queryData = [queryData];\n                        }\n                        for (const querySetWithFilter of filterState.querySets) {\n                            if (isInitialData && !querySetWithFilter.initialData)\n                                continue;\n                            let edsEvent = {\n                                type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.Message,\n                                connection: self,\n                                data: queryData,\n                                query: query,\n                                count: querySetWithFilter.count,\n                                retrieve: isInitialData,\n                            };\n                            for (let callback of querySetWithFilter.callbacks) {\n                                try {\n                                    callback(edsEvent);\n                                }\n                                catch (e) {\n                                    let msg = `Error while handling data for query: ${query}`;\n                                    const edsEvent = {\n                                        type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ClientQueryError,\n                                        connection: self,\n                                        data: e,\n                                        message: msg,\n                                        query: query\n                                    };\n                                    self.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                                    //self.filtersState.handleGlobalListener(edsEvent);\n                                }\n                            }\n                        }\n                        let filterToRemove = self.filtersState.tryToRemove(filterState, query);\n                        if (filterToRemove) {\n                            self.send(filterToRemove);\n                        }\n                    }\n                }\n            }\n            else {\n                let msg = data.error;\n                const queryErrorPrefix = \"Error parsing SQL query:\";\n                if (msg.startsWith(queryErrorPrefix)) {\n                    let query = msg.substring(queryErrorPrefix.length, msg.indexOf(\"ERROR\")).trim();\n                    const edsEvent = {\n                        type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ServerQueryError,\n                        connection: self,\n                        data: undefined,\n                        code: data.code,\n                        message: msg,\n                        query: query\n                    };\n                    let filterState = self.filtersState.filterForQuery(query);\n                    if (filterState) {\n                        for (const querySetWithFilter of filterState.querySets) {\n                            self.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                        }\n                    }\n                    //self.filtersState.handleGlobalListener(edsEvent);\n                }\n                else {\n                    const edsEvent = {\n                        type: _types__WEBPACK_IMPORTED_MODULE_0__.EDSEventType.ServerGlobalError,\n                        connection: self,\n                        data: undefined,\n                        code: data.code,\n                        message: msg\n                    };\n                    self.filtersState.handleGlobalListener(edsEvent);\n                }\n            }\n        }\n        else {\n            // retrieve properties\n            const lines = event.data.split(\"\\n\");\n            for (const line of lines) {\n                const keyValue = line.split(\":\");\n                if (keyValue.length == 2) {\n                    this.properties[keyValue[0].trim()] = keyValue[1].trim();\n                }\n            }\n        }\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n        if (this.pingIntervalId) {\n            clearInterval(this.pingIntervalId);\n        }\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    send(filter) {\n        var _a;\n        if (this.status() === _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Open) {\n            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(filter));\n        }\n    }\n    disconnect() {\n        var _a;\n        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    status() {\n        var _a;\n        switch ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) {\n            case WebSocket.CONNECTING:\n                return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Connecting;\n            case WebSocket.OPEN:\n                return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Open;\n            case WebSocket.CLOSING:\n                return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Closing;\n            default:\n                return _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Closed;\n        }\n    }\n    getId() {\n        return this.properties[_types__WEBPACK_IMPORTED_MODULE_0__.PHOTONIQ_ES];\n    }\n    getProperty(name) {\n        return this.properties[name];\n    }\n    getProperties() {\n        return this.properties;\n    }\n    updatePingInterval() {\n        var _a;\n        if (this.pingIntervalId !== undefined) {\n            clearInterval(this.pingIntervalId);\n            this.pingIntervalId = undefined;\n        }\n        let self = this;\n        if (!self.config.pingSeconds || self.config.pingSeconds > 0) {\n            this.pingIntervalId = setInterval(() => {\n                var _a;\n                if (self.status() === _types__WEBPACK_IMPORTED_MODULE_0__.ConnectionStatus.Open) {\n                    (_a = self.ws) === null || _a === void 0 ? void 0 : _a.send(\"{1}\");\n                }\n            }, ((_a = self.config.pingSeconds) !== null && _a !== void 0 ? _a : this.DEFAULT_PING_SECONDS) * 1000);\n        }\n    }\n    convertInitialData(sqlData) {\n        for (let sqlParameter in sqlData) {\n            let path = sqlParameter.split('.');\n            if (path.length <= 1) {\n                continue;\n            }\n            let value = sqlData;\n            for (let i = 0; i < path.length; i++) {\n                if (value[path[i]] === undefined) {\n                    value[path[i]] = {};\n                }\n                // if not last\n                if (i < path.length - 1) {\n                    value = value[path[i]];\n                }\n            }\n            value[path[path.length - 1]] = sqlData[sqlParameter];\n            delete sqlData[sqlParameter];\n        }\n        return sqlData;\n    }\n}\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/ws/ws-connection.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});