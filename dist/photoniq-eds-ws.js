/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PhotoniqEdsWs"] = factory();
	else
		root["PhotoniqEdsWs"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/connection-manager.ts":
/*!***********************************!*\
  !*** ./src/connection-manager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionManager = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst query_set_1 = __webpack_require__(/*! ./query-set */ \"./src/query-set.ts\");\nconst switchable_connection_1 = __webpack_require__(/*! ./switchable-connection */ \"./src/switchable-connection.ts\");\nconst filters_state_1 = __webpack_require__(/*! ./filters-state */ \"./src/filters-state.ts\");\n/**\n * The main class manages connection and queries.\n */\nclass ConnectionManager {\n    constructor(config, globalListener) {\n        this.config = config;\n        this.filtersState = new filters_state_1.FiltersState(globalListener);\n        this.connection = new switchable_connection_1.SwitchableConnection(this.config, this.filtersState);\n    }\n    /**\n     * Connect to Web Socket server\n     */\n    connect() {\n        let self = this;\n        this.connection.connect();\n        this.connection.onOpen(function (event) {\n            const edsEvent = {\n                type: types_1.EDSEventType.Open,\n                connection: self,\n                data: event\n            };\n            self.filtersState.handleGlobalListener(edsEvent);\n        });\n        this.connection.onMessage(function (data) {\n        });\n        this.connection.onClose(function (event) {\n            const edsEvent = {\n                type: types_1.EDSEventType.Close,\n                connection: self,\n                data: event\n            };\n            self.filtersState.handleGlobalListener(edsEvent);\n        });\n        this.connection.onError(function (event) {\n            const edsEvent = {\n                type: types_1.EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event,\n                message: \"Client error\",\n            };\n            self.filtersState.handleGlobalListener(edsEvent);\n        });\n    }\n    /**\n     * Send data directly to web socket\n     */\n    send(msg) {\n        this.connection.send(msg);\n    }\n    querySet() {\n        return new query_set_1.QuerySet(this, this.filtersState);\n    }\n    /**\n     * Disconnect from web socket\n     */\n    disconnect() {\n        this.connection.disconnect();\n    }\n    /**\n     * Get configuration of the connection\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get connection id\n     */\n    getId() {\n        return this.connection.getId();\n    }\n    /**\n     * Check weather it connected\n     */\n    status() {\n        return this.connection.status();\n    }\n    getProperty(name) {\n        return this.connection.getProperty(name);\n    }\n    getProperties() {\n        return this.connection.getProperties();\n    }\n}\nexports.ConnectionManager = ConnectionManager;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/connection-manager.ts?");

/***/ }),

/***/ "./src/filters-state.ts":
/*!******************************!*\
  !*** ./src/filters-state.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FiltersState = exports.REMOVE = exports.ADD = exports.TRUE = exports.FALSE = void 0;\nexports.FALSE = \"FALSE\";\nexports.TRUE = \"TRUE\";\nexports.ADD = \"add\";\nexports.REMOVE = \"remove\";\nclass FiltersState {\n    constructor(globalListener) {\n        this.queries = new Map();\n        this.globalListener = globalListener;\n    }\n    calculateFilter(action, query, filterState) {\n        const initialData = filterState.querySets.some(qs => qs.initialData && qs.count === 0) ? exports.TRUE : undefined;\n        const once = filterState.querySets.every(qs => qs.once) ? exports.TRUE : undefined;\n        const compress = filterState.querySets.some(qs => qs.compress) ? exports.TRUE : undefined;\n        return {\n            action: action,\n            queries: [query],\n            initialData: initialData,\n            once: once,\n            compress: compress\n        };\n    }\n    increment(filterState) {\n        // increment count for each query set\n        for (const qs of filterState.querySets) {\n            qs.count++;\n        }\n    }\n    tryToRemove(filterState, query) {\n        if (filterState.querySets.every(qs => qs.once)) {\n            this.queries.delete(query);\n            return {\n                action: exports.REMOVE,\n                queries: [query]\n            };\n        }\n        return undefined;\n    }\n    equalFiltersWithoutQueries(a, b) {\n        return a.action === b.action &&\n            a.compress === b.compress &&\n            a.initialData === b.initialData &&\n            a.once === b.once;\n    }\n    addQueries(queries, initialData, once, compress, querySet) {\n        let filtersToAdd = [];\n        for (const query of queries) {\n            let filterState = this.queries.get(query.query);\n            if (filterState) {\n                let filterBefore = this.calculateFilter(exports.ADD, query.query, filterState);\n                let querySetWithFilter = filterState.querySets.find(qs => qs.querySet === querySet);\n                if (querySetWithFilter) {\n                    querySetWithFilter.initialData = initialData;\n                    querySetWithFilter.once = once;\n                    querySetWithFilter.compress = compress;\n                    if (initialData) {\n                        querySetWithFilter.count = 0;\n                    }\n                    if (querySetWithFilter.callbacks.indexOf(query.listener) == -1) {\n                        querySetWithFilter.callbacks.push(query.listener);\n                    }\n                    if (querySetWithFilter.errorCallbacks.indexOf(query.errorListener) == -1) {\n                        querySetWithFilter.errorCallbacks.push(query.errorListener);\n                    }\n                }\n                else {\n                    let callbacks = [];\n                    if (query.listener) {\n                        callbacks.push(query.listener);\n                    }\n                    let errorCallbacks = [];\n                    if (query.errorListener) {\n                        errorCallbacks.push(query.errorListener);\n                    }\n                    filterState.querySets.push({\n                        querySet: querySet,\n                        initialData: initialData,\n                        compress: compress,\n                        once: once,\n                        count: 0,\n                        callbacks: query.listener ? [query.listener] : [],\n                        errorCallbacks: query.errorListener ? [query.errorListener] : [],\n                    });\n                }\n                let filterAfter = this.calculateFilter(exports.ADD, query.query, filterState);\n                if (!this.equalFiltersWithoutQueries(filterBefore, filterAfter)) {\n                    let filter = filtersToAdd.find(f => this.equalFiltersWithoutQueries(f, filterAfter));\n                    if (filter) {\n                        filter.queries.push(query.query);\n                    }\n                    else {\n                        filtersToAdd.push(filterAfter);\n                    }\n                }\n            }\n            else {\n                let filterState = {\n                    querySets: [{\n                            querySet: querySet,\n                            initialData: initialData,\n                            compress: compress,\n                            once: once,\n                            count: 0,\n                            callbacks: query.listener ? [query.listener] : [],\n                            errorCallbacks: query.errorListener ? [query.errorListener] : [],\n                        }]\n                };\n                this.queries.set(query.query, filterState);\n                let filterAfter = this.calculateFilter(exports.ADD, query.query, filterState);\n                let filter = filtersToAdd.find(f => this.equalFiltersWithoutQueries(f, filterAfter));\n                if (filter) {\n                    filter.queries.push(query.query);\n                }\n                else {\n                    filtersToAdd.push(filterAfter);\n                }\n            }\n        }\n        return filtersToAdd;\n    }\n    filterForQuery(query) {\n        return this.queries.get(query);\n    }\n    removeAllQueries(querySet) {\n        let queries = Array.from(this.queries.keys());\n        return this.removeQueries(queries, querySet);\n    }\n    removeQueries(queries, querySet) {\n        let queriesToRemove = [];\n        for (const query of queries) {\n            let remove = true;\n            let filterState = this.queries.get(query);\n            if (filterState) {\n                let index = filterState.querySets.findIndex(qs => qs.querySet === querySet);\n                if (index > -1) {\n                    filterState.querySets.splice(index, 1);\n                }\n                if (filterState.querySets.length) {\n                    remove = false;\n                }\n            }\n            if (remove) {\n                this.queries.delete(query);\n                queriesToRemove.push(query);\n            }\n        }\n        if (queriesToRemove.length) {\n            return {\n                action: exports.REMOVE,\n                queries: queriesToRemove\n            };\n        }\n        return undefined;\n    }\n    activeFilters() {\n        let filters = [];\n        for (const [query, filterState] of this.queries) {\n            const filter = this.calculateFilter(exports.ADD, query, filterState);\n            let filterFound = filters.find(f => this.equalFiltersWithoutQueries(f, filter));\n            if (filterFound) {\n                filterFound.queries.push(query);\n            }\n            else {\n                filters.push(filter);\n            }\n        }\n        return filters;\n    }\n    handleErrorListeners(errorCallbacks, query, edsEvent) {\n        for (let callback of errorCallbacks) {\n            try {\n                callback(edsEvent);\n            }\n            catch (e) {\n                console.warn(`Error while handling error listener for query: ${query}`, e);\n            }\n        }\n    }\n    handleGlobalListener(edsEvent) {\n        var _a;\n        try {\n            (_a = this.globalListener) === null || _a === void 0 ? void 0 : _a.call(this, edsEvent);\n        }\n        catch (e) {\n            console.warn(`Error while handling global error listener`, e);\n        }\n    }\n}\nexports.FiltersState = FiltersState;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/filters-state.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\nconst connection_manager_1 = __webpack_require__(/*! ./connection-manager */ \"./src/connection-manager.ts\");\n/**\n * Establish connection to PhotonIQ EDS server.\n * @param config configuration for the connection\n * @param globalListener listen all `EDSEvent` events.\n * @module connection\n */\nfunction connect(config, globalListener) {\n    let connection = new connection_manager_1.ConnectionManager(config, globalListener);\n    connection.connect();\n    return connection;\n}\nexports.connect = connect;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/index.ts?");

/***/ }),

/***/ "./src/query-batch.ts":
/*!****************************!*\
  !*** ./src/query-batch.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueryBatch = void 0;\n/**\n * @module QueryBatch\n * Joins all querues togather and sends as a batch\n */\nclass QueryBatch {\n    /** @ignore */\n    constructor(querySet, connection, filtersState) {\n        this.subscribeQueries = [];\n        this.retrieveAndSubscribeQueries = [];\n        this.retrieveQueries = [];\n        this.unsubscribeQueries = [];\n        this.querySet = querySet;\n        this.connection = connection;\n        this.filtersState = filtersState;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        this.subscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieveAndSubscribe(query, listener, errorListener) {\n        this.retrieveAndSubscribeQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieve(query, listener, errorListener) {\n        this.retrieveQueries.push({\n            query: query,\n            listener: listener,\n            errorListener: errorListener\n        });\n        return this;\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        this.unsubscribeQueries.push(query);\n        return this;\n    }\n    /**\n     * Assemble list of queries to batch request\n     */\n    assemble() {\n        let filters = this.filtersState.addQueries(this.retrieveQueries, true, true, false, this.querySet);\n        let retrieveAndSubscribeFilters = this.filtersState.addQueries(this.retrieveAndSubscribeQueries, true, false, false, this.querySet);\n        this.joinFilters(filters, retrieveAndSubscribeFilters);\n        let subscribeFilters = this.filtersState.addQueries(this.subscribeQueries, false, false, false, this.querySet);\n        this.joinFilters(filters, subscribeFilters);\n        for (const filterToAdd of filters) {\n            this.connection.send(JSON.stringify(filterToAdd));\n        }\n        let unsubscribeFilter = this.filtersState.removeQueries(this.unsubscribeQueries, this.querySet);\n        if (unsubscribeFilter) {\n            this.connection.send(JSON.stringify(unsubscribeFilter));\n        }\n    }\n    joinFilters(target, source) {\n        for (const sourceFilter of source) {\n            let filter = target.find(f => this.filtersState.equalFiltersWithoutQueries(f, sourceFilter));\n            if (filter) {\n                filter.queries.push(...sourceFilter.queries);\n            }\n            else {\n                target.push(sourceFilter);\n            }\n        }\n    }\n}\nexports.QueryBatch = QueryBatch;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-batch.ts?");

/***/ }),

/***/ "./src/query-set.ts":
/*!**************************!*\
  !*** ./src/query-set.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (C) Macrometa, Inc - All Rights Reserved\n *\n * Unauthorized copying of this file, via any medium is strictly prohibited\n * Proprietary and confidential\n * Written by Macrometa, Inc <product@macrometa.com>, May 2024\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuerySet = void 0;\nconst query_batch_1 = __webpack_require__(/*! ./query-batch */ \"./src/query-batch.ts\");\n/**\n * Manages queries as a set\n */\nclass QuerySet {\n    /** @ignore */\n    constructor(connection, filtersState) {\n        this.connection = connection;\n        this.filtersState = filtersState;\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    subscribe(query, listener, errorListener) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, false, false, false, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(JSON.stringify(filterToAdd));\n        }\n    }\n    /**\n     * Subscribe to query. Returns result when update happens by the query\n     * @param query SQL query to be subscribed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieveAndSubscribe(query, listener, errorListener) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, true, false, false, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(JSON.stringify(filterToAdd));\n        }\n    }\n    /**\n     * Retrieve query. Returns result as usual DB call.\n     * @param query SQL query to be executed\n     * @param listener callback function which returns result as an instance of EDSEventMessage\n     * @param errorListener callback function which returns error result as an instance of EDSEventError\n     */\n    retrieve(query, listener, errorListener) {\n        let queries = [{\n                query: query,\n                listener: listener,\n                errorListener: errorListener\n            }];\n        let filtersToAdd = this.filtersState.addQueries(queries, true, true, false, this);\n        for (const filterToAdd of filtersToAdd) {\n            this.connection.send(JSON.stringify(filterToAdd));\n        }\n    }\n    /**\n     * Unsubscribe from the query.\n     * @param query SQL query to be unsubscribed\n     */\n    unsubscribe(query) {\n        let filterToRemove = this.filtersState.removeQueries([query], this);\n        if (filterToRemove) {\n            this.connection.send(JSON.stringify(filterToRemove));\n        }\n    }\n    /**\n     * Unsubscribe from all query in the QuerySet.\n     */\n    unsubscribeAll() {\n        let filter = this.filtersState.removeAllQueries(this);\n        if (filter) {\n            this.connection.send(JSON.stringify(filter));\n        }\n    }\n    /**\n     * Create QueryBatch instance to join all queries in one request and assemble at the end.\n     */\n    batch() {\n        return new query_batch_1.QueryBatch(this, this.connection, this.filtersState);\n    }\n}\nexports.QuerySet = QuerySet;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/query-set.ts?");

/***/ }),

/***/ "./src/sse/event-source.ts":
/*!*********************************!*\
  !*** ./src/sse/event-source.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventSource = void 0;\nclass EventSource {\n    constructor(url, headers) {\n        this.url = url;\n        this.headers = headers;\n        /*this.xhr = new XMLHttpRequest();\n        \n        this.xhr.open('POST', url, true);\n        \n        for (const key in headers) {\n            this.xhr.setRequestHeader(key, headers[key]);\n        }\n    \n        let self = this;\n        this.xhr.onreadystatechange = () => {\n            if (self.xhr.readyState === 2 || self.xhr.readyState === 3) {\n                if (self.xhr.status >=200 && self.xhr.status < 300) {\n                    let message = self.xhr.responseText.substring(self.index);\n                    self.index = self.xhr.responseText.length;\n                    console.log('Message:', message);\n                    if (self.messageListener) {\n                        self.messageListener(message);\n                    }\n                } else {\n                    console.error('Error:', self.xhr.statusText);\n                    if (self.errorListener) {\n                        self.errorListener(self.xhr.statusText);\n                    }\n                }\n            }\n        };\n    \n        this.xhr.onerror = () => {\n            console.error('Request error:', this.xhr.statusText);\n        };*/\n    }\n    onopen(listener) {\n        this.openListener = listener;\n    }\n    onmessage(listener) {\n        this.messageListener = listener;\n    }\n    onerror(listener) {\n        this.errorListener = listener;\n    }\n    onclose(listener) {\n        this.closeListener = listener;\n    }\n    connect(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield fetch(this.url, {\n                    method: 'POST',\n                    headers: this.headers,\n                    body: JSON.stringify(data),\n                });\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                const stream = response.body;\n                const reader = stream.getReader();\n                let result;\n                while (!(result = yield reader.read()).done) {\n                    let v = new TextDecoder('utf-8').decode(result.value);\n                    console.log('Response data:', v);\n                }\n            }\n            catch (error) {\n                console.error('There was a problem with the fetch operation:', error);\n            }\n        });\n    }\n}\nexports.EventSource = EventSource;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/sse/event-source.ts?");

/***/ }),

/***/ "./src/sse/sse-connection.ts":
/*!***********************************!*\
  !*** ./src/sse/sse-connection.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SseConnection = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst event_source_1 = __webpack_require__(/*! ./event-source */ \"./src/sse/event-source.ts\");\nclass SseConnection {\n    constructor(config) {\n        this.config = config;\n    }\n    send(msg) {\n    }\n    /**\n     * Connect to SSE server\n     */\n    connect() {\n        const url = `https://${this.config.host}/api/es/sse/v1/subscribe`;\n        let data = {\n            \"type\": \"collection\",\n            \"fabric\": \"_system\",\n            \"filters\": {\n                \"once\": \"FALSE\",\n                \"compress\": \"FALSE\",\n                \"initialData\": \"TRUE\",\n                \"queries\": [\"select * from box_trim where attendance=4\"]\n            }\n        };\n        /*const ctrl = new AbortController();\n        fetchEventSource(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `${this.config.apiKey}`,\n                'x-customer-id': `${this.config.customerId}`,\n            },\n            body: JSON.stringify(data),\n            signal: ctrl.signal,\n            onmessage(ev) {\n                console.log(ev.data);\n            }\n        });*/\n        this.sse = new event_source_1.EventSource(url, {\n            'Content-Type': 'application/json',\n            'Authorization': `${this.config.apiKey}`,\n            'x-customer-id': `${this.config.customerId}`,\n        });\n        let self = this;\n        this.sse.onopen = (event) => {\n            console.log('Connection to SSE server opened.', event);\n            /*const edsEvent: EDSEvent = {\n                type: EDSEventType.Open,\n                connection: self,\n                data: event\n            };\n            self.handleGlobalListener(edsEvent);*/\n        };\n        this.sse.onmessage = (event) => {\n            console.log('Received event:', event);\n            /*const edsEvent: EDSEvent = {\n                type: EDSEventType.Message,\n                connection: self,\n                data: event\n            };\n            self.handleGlobalListener(edsEvent);*/\n        };\n        this.sse.onerror = (event) => {\n            console.error('Error occurred:', event);\n            /*const edsEvent: EDSEvent = {\n                type: EDSEventType.ClientGlobalError,\n                connection: self,\n                data: event\n            };\n            self.handleGlobalListener(edsEvent);*/\n        };\n        this.sse.connect(data);\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    status() {\n        return types_1.ConnectionStatus.Closed;\n    }\n    disconnect() {\n    }\n    getId() {\n        return undefined;\n    }\n    getProperty(name) {\n        return undefined;\n    }\n    getProperties() {\n        return {};\n    }\n}\nexports.SseConnection = SseConnection;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/sse/sse-connection.ts?");

/***/ }),

/***/ "./src/switchable-connection.ts":
/*!**************************************!*\
  !*** ./src/switchable-connection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwitchableConnection = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst ws_connection_1 = __webpack_require__(/*! ./ws/ws-connection */ \"./src/ws/ws-connection.ts\");\nconst sse_connection_1 = __webpack_require__(/*! ./sse/sse-connection */ \"./src/sse/sse-connection.ts\");\nclass SwitchableConnection {\n    constructor(config, filtersState) {\n        this.connectionTypes = [\"ws\" /*, \"sse\"*/];\n        this.reconnection = -1;\n        this.config = config;\n        this.filtersState = filtersState;\n    }\n    connect() {\n        if (this.connection)\n            throw new Error(`Already connected with status: ${this.status()}`);\n        // move primary connection to first position of connectionTypes array\n        if (this.config.primaryConnection) {\n            let index = this.connectionTypes.indexOf(this.config.primaryConnection);\n            if (index === -1)\n                throw new Error(`Wrong connection type set as primaryConnection: ${this.config.primaryConnection}`);\n            const [primaryConnection] = this.connectionTypes.splice(index, 1);\n            this.connectionTypes.unshift(primaryConnection);\n        }\n        let connectionType = this.connectionTypes[this.reconnection % this.connectionTypes.length];\n        switch (connectionType) {\n            case \"ws\":\n                this.connection = new ws_connection_1.WsConnection(this.config, this.filtersState);\n                break;\n            case \"sse\":\n                this.connection = new sse_connection_1.SseConnection(this.config);\n                break;\n            default:\n                throw new Error(`Connection type not supported: ${connectionType}`);\n        }\n        let self = this;\n        this.connection.onOpen(function (event) {\n            var _a, _b;\n            let reconnection = self.reconnection;\n            self.reconnection = 0;\n            if (reconnection === -1) {\n                (_a = self.openListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n            }\n            // send current subscribed filters.\n            let filters = self.filtersState.activeFilters();\n            for (const filter of filters) {\n                (_b = self.connection) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify(filter));\n            }\n        });\n        this.connection.onMessage(function (event) {\n            var _a;\n            (_a = self.messageListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n        this.connection.onError(function (event) {\n            var _a;\n            (_a = self.errorListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n        this.connection.onClose(function (event) {\n            var _a;\n            self.connection = undefined;\n            if (self.reconnection > -1) {\n                let millisToReconnect = Math.pow(2, 6 + self.reconnection++);\n                setTimeout(function () {\n                    self.connect();\n                }, millisToReconnect);\n            }\n            else {\n                self.reconnection = 0;\n                (_a = self.closeListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n            }\n        });\n        this.connection.connect();\n    }\n    send(msg) {\n        var _a;\n        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.send(msg);\n    }\n    disconnect() {\n        var _a;\n        this.reconnection = -1;\n        (_a = this.connection) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    status() {\n        if (this.connection) {\n            return this.connection.status();\n        }\n        else {\n            return types_1.ConnectionStatus.Closed;\n        }\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    getId() {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.getId();\n    }\n    getProperty(name) {\n        var _a;\n        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.getProperty(name);\n    }\n    getProperties() {\n        return this.connection ? this.connection.getProperties() : {};\n    }\n}\nexports.SwitchableConnection = SwitchableConnection;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/switchable-connection.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionStatus = exports.EDSEventType = exports.PHOTONIQ_ES = void 0;\n/**\n * @module Types\n *\n *\n */\nexports.PHOTONIQ_ES = \"x-photoniq-es\";\n/**\n * List of event types generated by EDS driver\n*/\nvar EDSEventType;\n(function (EDSEventType) {\n    EDSEventType[\"Open\"] = \"open\";\n    EDSEventType[\"Close\"] = \"close\";\n    EDSEventType[\"ConnectionId\"] = \"connection-id\";\n    EDSEventType[\"ServerQueryError\"] = \"server-query-error\";\n    EDSEventType[\"ServerGlobalError\"] = \"server-global-error\";\n    EDSEventType[\"ClientQueryError\"] = \"client-query-error\";\n    EDSEventType[\"ClientGlobalError\"] = \"client-global-error\";\n    EDSEventType[\"Message\"] = \"message\";\n})(EDSEventType || (exports.EDSEventType = EDSEventType = {}));\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n    ConnectionStatus[\"Closed\"] = \"closed\";\n    ConnectionStatus[\"Connecting\"] = \"connecting\";\n    ConnectionStatus[\"Open\"] = \"open\";\n    ConnectionStatus[\"Closing\"] = \"closing\";\n})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/types.ts?");

/***/ }),

/***/ "./src/ws/ws-connection.ts":
/*!*********************************!*\
  !*** ./src/ws/ws-connection.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WsConnection = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nclass WsConnection {\n    constructor(config, filtersState) {\n        this.STUB_FILTER = \"%7B%22action%22%3A%22remove%22%2C%22queries%22%3A%5B%22SELECT%20%2A%20FROM%20fake%22%5D%7D\";\n        /**\n         * Default timeoput of ping-pong requests in seconds\n         */\n        this.DEFAULT_PING_SECONDS = 29;\n        this.properties = {};\n        this.config = config;\n        this.filtersState = filtersState;\n    }\n    connect() {\n        let self = this;\n        const url = `wss://${this.config.host}/api/es/v1/subscribe?type=collection` +\n            `&x-customer-id=${this.config.customerId}` +\n            `&apiKey=${this.config.apiKey}` +\n            `&fabric=${this.config.fabric}` +\n            `&filters=${this.STUB_FILTER}`;\n        this.ws = new WebSocket(url);\n        this.ws.addEventListener('open', function (event) {\n            var _a;\n            (_a = self.openListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n            self.updatePingInterval();\n        });\n        this.ws.addEventListener('message', function (event) {\n            var _a;\n            let message = self.handleMessage(event);\n            if (message) {\n                (_a = self.messageListener) === null || _a === void 0 ? void 0 : _a.call(self, message);\n            }\n            self.updatePingInterval();\n        });\n        this.ws.addEventListener('close', function (event) {\n            var _a;\n            (_a = self.closeListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n        this.ws.addEventListener('error', function (event) {\n            var _a;\n            (_a = self.errorListener) === null || _a === void 0 ? void 0 : _a.call(self, event);\n        });\n    }\n    onOpen(listener) {\n        this.openListener = listener;\n    }\n    onMessage(listener) {\n        this.messageListener = listener;\n    }\n    handleMessage(event) {\n        let self = this;\n        if (self.properties[types_1.PHOTONIQ_ES]) {\n            let data = JSON.parse(event.data);\n            if (!data.error) {\n                for (let query in data) {\n                    let queryData = data[query];\n                    let filterState = self.filtersState.filterForQuery(query);\n                    if (filterState) {\n                        self.filtersState.increment(filterState);\n                        let isInitialData = Array.isArray(queryData);\n                        if (isInitialData) {\n                            for (let i = 0; i < queryData.length; i++) {\n                                queryData[i] = self.convertInitialData(queryData[i]);\n                            }\n                        }\n                        else {\n                            queryData = [queryData];\n                        }\n                        for (const querySetWithFilter of filterState.querySets) {\n                            if (isInitialData && !querySetWithFilter.initialData)\n                                continue;\n                            let edsEvent = {\n                                type: types_1.EDSEventType.Message,\n                                connection: self,\n                                data: queryData,\n                                query: query,\n                                count: querySetWithFilter.count,\n                                retrieve: isInitialData,\n                            };\n                            for (let callback of querySetWithFilter.callbacks) {\n                                try {\n                                    callback(edsEvent);\n                                }\n                                catch (e) {\n                                    let msg = `Error while handling data for query: ${query}`;\n                                    const edsEvent = {\n                                        type: types_1.EDSEventType.ClientQueryError,\n                                        connection: self,\n                                        data: e,\n                                        message: msg,\n                                        query: query\n                                    };\n                                    self.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                                    //self.filtersState.handleGlobalListener(edsEvent);\n                                }\n                            }\n                        }\n                        let filterToRemove = self.filtersState.tryToRemove(filterState, query);\n                        if (filterToRemove) {\n                            self.send(JSON.stringify(filterToRemove));\n                        }\n                    }\n                }\n            }\n            else {\n                let msg = data.error;\n                const queryErrorPrefix = \"Error parsing SQL query:\";\n                if (msg.startsWith(queryErrorPrefix)) {\n                    let query = msg.substring(queryErrorPrefix.length, msg.indexOf(\"ERROR\")).trim();\n                    const edsEvent = {\n                        type: types_1.EDSEventType.ServerQueryError,\n                        connection: self,\n                        data: undefined,\n                        code: data.code,\n                        message: msg,\n                        query: query\n                    };\n                    let filterState = self.filtersState.filterForQuery(query);\n                    if (filterState) {\n                        for (const querySetWithFilter of filterState.querySets) {\n                            self.filtersState.handleErrorListeners(querySetWithFilter.errorCallbacks, query, edsEvent);\n                        }\n                    }\n                    //self.filtersState.handleGlobalListener(edsEvent);\n                }\n                else {\n                    const edsEvent = {\n                        type: types_1.EDSEventType.ServerGlobalError,\n                        connection: self,\n                        data: undefined,\n                        code: data.code,\n                        message: msg\n                    };\n                    self.filtersState.handleGlobalListener(edsEvent);\n                }\n            }\n        }\n        else {\n            // retrieve properties\n            const lines = event.data.split(\"\\n\");\n            for (const line of lines) {\n                const keyValue = line.split(\":\");\n                if (keyValue.length == 2) {\n                    this.properties[keyValue[0].trim()] = keyValue[1].trim();\n                }\n            }\n        }\n    }\n    onClose(listener) {\n        this.closeListener = listener;\n        if (this.pingIntervalId) {\n            clearInterval(this.pingIntervalId);\n        }\n    }\n    onError(listener) {\n        this.errorListener = listener;\n    }\n    send(msg) {\n        var _a;\n        if (this.status() === types_1.ConnectionStatus.Open) {\n            (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(msg);\n        }\n    }\n    disconnect() {\n        var _a;\n        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    status() {\n        var _a;\n        switch ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) {\n            case WebSocket.CONNECTING:\n                return types_1.ConnectionStatus.Connecting;\n            case WebSocket.OPEN:\n                return types_1.ConnectionStatus.Open;\n            case WebSocket.CLOSING:\n                return types_1.ConnectionStatus.Closing;\n            default:\n                return types_1.ConnectionStatus.Closed;\n        }\n    }\n    getId() {\n        return this.properties[types_1.PHOTONIQ_ES];\n    }\n    getProperty(name) {\n        return this.properties[name];\n    }\n    getProperties() {\n        return this.properties;\n    }\n    updatePingInterval() {\n        var _a;\n        if (this.pingIntervalId !== undefined) {\n            clearInterval(this.pingIntervalId);\n            this.pingIntervalId = undefined;\n        }\n        let self = this;\n        if (!self.config.pingSeconds || self.config.pingSeconds > 0) {\n            this.pingIntervalId = setInterval(() => {\n                self.send(\"{1}\");\n            }, ((_a = self.config.pingSeconds) !== null && _a !== void 0 ? _a : this.DEFAULT_PING_SECONDS) * 1000);\n        }\n    }\n    convertInitialData(sqlData) {\n        for (let sqlParameter in sqlData) {\n            let path = sqlParameter.split('.');\n            if (path.length <= 1) {\n                continue;\n            }\n            let value = sqlData;\n            for (let i = 0; i < path.length; i++) {\n                if (value[path[i]] === undefined) {\n                    value[path[i]] = {};\n                }\n                // if not last\n                if (i < path.length - 1) {\n                    value = value[path[i]];\n                }\n            }\n            value[path[path.length - 1]] = sqlData[sqlParameter];\n            delete sqlData[sqlParameter];\n        }\n        return sqlData;\n    }\n}\nexports.WsConnection = WsConnection;\n\n\n//# sourceURL=webpack://PhotoniqEdsWs/./src/ws/ws-connection.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});